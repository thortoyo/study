---------------------------------------------------------------------
AGC039 A
---------------------------------------------------------------------
連続文字
2	a a b
	  *		1回
3	a a a b
	  *		1回
4	a a a a b
	  *   *		2回
5	a a a a a b
	  *   * 	2回	n / 2 回
端っこ
	a b c d a	
	        *	1回
	a b c a a	
	        *	1回
	a b a a a	
	    *   *	2回
	a a b a a	
	*     *		2回
最初と最後
	a b a a/a b a a/a b a a
	      *       *       *

---------------------------------------------------------------------
AGC039 B
---------------------------------------------------------------------
頂点は200、辺は40000が最大なので、全部順番に調べれればOK
ある頂点から辺をたどると、必ず隣り合う集合になる。
V1 と Vk は特別で、となりあう集合が1つしかない。
辺がない頂点は、独立の集合にして問題ない。
出自数が1の頂点は、隣り合う集合が2個ある集合にいれても仕方ない？
なので、こいつを探して、V1にしてみる？



---------------------------------------------------------------------
AGC039 C
---------------------------------------------------------------------
011
001
000
100
110
111
011

1011
0101
0010
1001
0100
1010
1101
0110
1011

0000
1000
1100
1110
1111
0111
0011
0001
0000

000
100
110
111
011
001
000

101
010
101


1 0 1
2 3 6

1 1 0
2 4 7

1 1 1
2 4 8

1010
0101

110011
011001
001100
100110
110011


---------------------------------------------------------------------
ABC144 C
---------------------------------------------------------------------
因数分解して、全組み合わせを見て、数字の合計が一番小さいのを選ぶ。

0 1 -> 2
0 1 2 -> 3
1 << 0	1
1 << 1	2
1 << 2	4

16
2 * 2 * 2 * 2
4*4


---------------------------------------------------------------------
ABC145 D
---------------------------------------------------------------------
(6,6) だとすると
(1,2) (2,4) (4,5) (6,6)
(1,2) (3,3) (4,5) (6,6)
(1,2) (3,3) (5,4) (6,6)
(2,1) (3,3) (5,4) (6,6)
どっちの方法を使っても一度に増える座標の合計は 3
なので、XとYを足した合計は3の倍数である必要がある。
で、(X+Y)/3 で必要な手数が出る。
それが 出たら、X と Y から引く。
そこで マイナスになったら NG
あとは単純な格子の場合の数。
X最大は 10^6 だけど、だいたい 1/3 になる
けど、それが X と Y 両方あるとでかいなあ。。。
10^6 = 1,000,000 = 1M
X Y 両方あったら 1T
DPではできない。
 (X+Y)! / (X! * Y!)
で計算できそう。
今回階乗が多いな。

---------------------------------------------------------------------
ABC146 D
---------------------------------------------------------------------
辺を塗り分けるか。
どうやったら辺を塗り分ける判定ができる？
適当に割り当ててみる？
木！
見落としてた！
木やったら簡単。
辺を順番に見ていきながら、同じ頂点からのものならインクリメントしていく。
出し元ノードが変わったら数字を元に戻す。
先ノードにすでにその番号の辺が、、、いや、木だから無い！



-----------------------------------------------------------------------
sumitb2019 D - Lucky PIN
-----------------------------------------------------------------------
順番を守りながら3つ数字を選ぶ。
Nは30000。3*10^4
単純に列挙するのは O(N^3) なので無理。
左から順に処理
最初の三文字の時点では、1個。
最大でも1000個なので、setで管理。
現状でありうる上位2桁を覚えておく。
新たな1桁と、それら上位のセットを全部作って、setに乗せる。
それから新たな1桁を使って、上位のセットを追加する。
 1桁目を2桁目に入れて、新1桁を1桁目に入れる。
 これを上位セットに追加。


-----------------------------------------------------------------------
sumitb2019 E - Colorful Hats 2
-----------------------------------------------------------------------
前から単純に数えていいのか？
i - Ai
0 1 2 0 0 1
1 1 1 2 3 2
          3


-----------------------------------------------------------------------
ABC116 D - Various Sushi
-----------------------------------------------------------------------
種類がなければ普通のDP
種類があるので、どれを取ったかを記憶してないと、カレントのスシを取った時に
種類数を加算するかが判断できない。
事前の準備が多分必要
事前に種類番号でソートしておくと、何とかなりそう
そうしておくと、種類数をインクリメントするときは種類番号の切り替わり時のみ
なので、切り替わり後に、現在の種類をすでに取ったか、だけを把握しておけばいけそう。
	dp[i][j]	i個取っていて、現在の値をすでに
いや、dp[N][K] の時点ですでに 10^10 なので不可！
別の方法を考える必要がある。

種類がなければ、味でソートして大きい順にK個取ればOK。
K個取ってから、残りから種類が異なるものを選んで、その中の味が大きいものと
入れ替えていって、入れ替えても点数が大きくならなくなるまで続ける？
 

-----------------------------------------------------------------------
ABC119 D - Lazy Faith
-----------------------------------------------------------------------

-----------------------------------------------------------------------
ABC115 D
-----------------------------------------------------------------------
BB..B PP..P
  L   
L			total	paty
0	1		1	1
1	3 + 2*L(-1)	5	3	1 + 2*L[-1]
2	3 + 2*L(-1)	13	7	1 + 2*L[-1]
3	3 + 2*L(-1)	29	15	1 + 2*L[-1]


P
	1
B P P P B
	3
B BPPPB P BPPPB B
	3 1 3
B B BPPPB P BPPPB B P B BPPPB P BPPPB B B
	3 1 3 1 3 1 3
B B B BPPPB P BPPPB B P B BPPPB P BPPPB B B P B B BPPPB P BPPPB B P B BPPPB P BPPPB B B B
	3 1 3 1 3 1 3 1 3 1 3 1 3 1 3
	4 3 1 1 1 3 

-----------------------------------------------------------------------
ABC114 C
-----------------------------------------------------------------------
上位の桁から順に累積していくやつ
	2	5	4	9
	0	2*3=6	
	0	1
いや、この問題の場合、各桁は独立して計算可能か

問題間違えた。。。
7 と 5 と 3 がそれぞれ１回以上登場する場合の数
あ、さらに、それ以外の数字が出てこない場合か。
10^9 までの数だけど、実際に探索する必要があるのは 3^8 になるので
全探索が余裕になる

こういうのは、基本は再帰らしい。

-----------------------------------------------------------------------
ABC114 D
-----------------------------------------------------------------------
N! の約数なので、1～Nまでを素因数分解して、それらから選んだのが約数になる
約数の個数を数える必要がある。
例えば 12 だと、12 = 2*2*3
約数は、1,2,3,4,6,12 の6個
2 が2個、3が1個
2を選ばない場合も含めると、
2を選ぶ個数は 3 パターン、3を選ぶ個数は 2 パターン
	3*2=6
が、約数の個数になる
36 = 2*2*3*3
約数は、1,2,3,4,6,9,12,18,36 の9個
3*3=9 個

約数の合計が75個というのは、
75 = 3*5*5
なので、ありうるパターンとしては
	75
	3, 25
	3, 5, 5
	5, 15
の4パターン

1～Nの各数を素因数分解して、各素数ごとの合計個数を累積
Nは100未満なので、
innsu[100]
に累積する。
そして、上記4パターンの取りうる数をそれぞれ計算し、合計すればいい。

-----------------------------------------------------------------------
ABC149 D
-----------------------------------------------------------------------

-----------------------------------------------------------------------
ABC149 E
-----------------------------------------------------------------------
Ai 大きい順にソートしておく
一回の握手で点が大きいのは順に
	M/3
A0,A0	0
A0,A1	0
A1,A0	0
A1,A1	1
A1,A2	1
A2,A1	1
A2,A2	2
A2,A3	2
A3,A2	2
A3,A3	3
 :
という順になる
なので、Mを3で割って、そのあまりがいくつかで、場合分けすればいい？
A[M/3-1] までAiを合計。それを6倍。A0*3 を引く。
余り 0	A[M/3]*2を加算
余り 1	A[M/3]*4を加算
余り 2	A[M/3]*5、A[M3+1]を加算

違う！
A0,A0	0
A0,A1	0
A1,A0	0
ここまでは正しいけど、次が A1,A1 か、A0,A2 かは不明

二分探索か。
ある点数が実現可能かを求められればいい。

M回の握手なので、Ai は 2M 個足される。
A1,A0	= A0 + A0 - (A0 - A1)
A1,A1 = A1+A0-(A0-A1) = A0+A0-(A0-A1)-(A0-A1)
A2,A0 = A1+A0-(A1-A2) = A0+A0-(A1-A2)-(A0-A1)

わからん、、、
解説を見る。

N*Nの表ができるので、その表の中から大きい順にM個取った場合が答え。
けど、それでは時間がかかりすぎる。
よって、ある数以上であるマスの個数を数えて、それがMをちょうど超える場合を探す。


-----------------------------------------------------------------------
ABC150 C
-----------------------------------------------------------------------
最大でも8!なので、40320通りしかない。
よって総当たり。
総当たりでPとQとに一致するのを探して、そのときの順番を記憶して答えを出す。

pythonでの順列列挙(辞書順に出力)
import itertools
itertools.pamutations( list )

-----------------------------------------------------------------------
ABC150 D
-----------------------------------------------------------------------
0.5 がなければ、普通に公倍数を求める問題
X = A0 * p0 + A0 * 0.5
X = A1 * p1 + A1 * 0.5
X = A2 * p2 + A2 * 0.5
というX
Xの最小が求まれば、その整数倍も条件を満たすのか？

単純に計算するなら？
 A0に関して、Xの候補を全部挙げる O(M)
 A1に関して、Xの候補を全部挙げて、A0での候補と一致するのを残す O(M)
 で、 O(NM)
なので、間に合わない。

2X = A0 * (p0 * 2 + 1)
2X = A1 * (p1 * 2 + 1)
2X = A2 * (p2 * 2 + 1)
としたら、An の奇数倍の最小公倍数を求めたらいい。
奇数倍の最小公倍数とは？


-----------------------------------------------------------------------
ABC152 E
-----------------------------------------------------------------------
最小公倍数を求めて、各Aをそれで割った値を合計すればいい。
けど、最小公倍数がすごく大きくなる。
python ならいけるかと思って、普通に計算する答えを出したけど、一つだけTLE
どうやって計算量を落とす？
逆元を使って、LCMって計算できるのか？
できない気がする。。
 
-----------------------------------------------------------------------
ABC152 D
-----------------------------------------------------------------------


---------------------------------------------------------------------
ABC153 F
---------------------------------------------------------------------
Xが10^9あるので、各地点で爆弾を置いた場合の影響を求めるのはNG
また、Dも10^9あるので、毎回範囲ないにどのモンスターがいるかを判定するのもNG
候補位置は各Xi＋D と -D の位置のみ、でそれ以外の位置は意味がない。	4*10^5
 いや、1,4,1 と並んでたら、+-D位置のみなら 5 回になるけど、4 の位置に置いたら 4 回
  いや、、1 の +-D 位置で計算したら 4 回が出てくる。
爆弾ダメージはA固定なので、必要な回数はあらかじめ計算可能。
爆弾候補位置のリストに、その爆弾によってHitするモンスターの番号のリスト、までは作ることができる。
問題はどうやって最小を求めるか。


---------------------------------------------------------------------
ABC154 D
---------------------------------------------------------------------
N=5
0  1  2  3  4
2  5  3  4  3
0  2  7 10 14 17
K=3


---------------------------------------------------------------------
ABC104 C
---------------------------------------------------------------------
DP[i][p]: i問題までで、p問解いた時の最大点


---------------------------------------------------------------------
ABC104 D
---------------------------------------------------------------------
Bを固定して考えたらいけそう？
"?" も含んで、先頭から順に B の位置を決めて、その前にある Aの個数、
その後ろにある C の個数を数えて掛け合わせる。
前にあるAの個数は A と ? に合計でOK
個数は、先頭から順にカウントアップしながら AB[i] の配列に入れていけばいい。
i はBの文字位置。
Cの個数も逆に右からもう一回ループ回したらいい

---------------------------------------------------------------------
ABC155 D
---------------------------------------------------------------------
a b c
a

a b c d		6
ab < ac < bc < bd < cd
          ad
a b c d e	10
ab < ac < ad < ae < be < ce < de
          bc < bd < cd

a b c d e f	15
ab < ac < ad < ae < af < bf < cf < df < ef
          bc < bd < be < ce < de
                  cd


bc < bd < be < ce < de


---------------------------------------------------------------------
ABC155 E
---------------------------------------------------------------------
	3	2	4
	3	2	4

		3	0
	7+1	0	6

		0
		7

	0
	6

1
0


	3	0	4

		1	0
		0	6

		0
		9

---------------------------------------------------------------------
pana2020 E
---------------------------------------------------------------------
a-b
b-a
a-c
c-a
b-c
c-b
の最短をそれぞれ求める。
a	len(a)	|---------|
b	len(b)	    |-------------|
		    |-----|
		       ab
		a-ab         b-ab
b	len(b)	|-----------|
c	len(c)	         |--------|
		         |--|
		 b-bc     bc   c-bc
a-ab + b + c -bc
= a+b+c -ab-bc
なので、ab+bc が一番小さいのを選べばOK

bがaに含まれている場合はどうしたらいい？
ba=ab=0 ？
c-a と a-c の比較をすればいけそうだけど、ほんとうにそれが最短か？
一番重なりが小さいほうから探して、後ろが一致したら止まればいい。
前後逆で探索もするので、後ろ一致で途中で止まっても、逆からの探索の時に
残りの位置の比較も行われる。


---------------------------------------------------------------------
ABC160 D
---------------------------------------------------------------------
2*10^3
全頂点からダイクストラすると、
N*NlogN
なので10^7ぐらいなのでぎりぎり？
いや、距離がkなのを探すので
N*N*NlogN
なのでNG

辺が1個追加なのがポイントか。
X - Y が追加
X <= k なら前に1個
N-Y >= k なら後ろに1個

---------------------------------------------------------------------
ABC090 D
---------------------------------------------------------------------
a = bx + K以上
K >= a - bx
b > K

N-K = bx
b = [K+1, N]
k = [K, b)
a-k = bx

	      b
a	+-----+-----+-----+-----+...
	
b  a	1	2	3	4	5
1	0	0	0	0	0
2	1	0	1	0	1
3	1	2	0	1	2
4	1	2	3	0	1
5	1	2	3	4	0

b  a	1	2	3	4	5	6	7	8	9	10
1	0	0	0	0	0	0	0	0	0	0
2	1	0	1	0	1	0	1	0	1	0
3	1	2	0	1	2	0	1	2	0	1
4	1	2	3	0	1	2	3	0	1	2
5	1	2	3	4	0	1	2	3	4	0
6	1	2	3	4	5	0	1	2	3	4
7	1	2	3	4	5	6	0	1	2	3
8	1	2	3	4	5	6	7	0	1	2
9	1	2	3	4	5	6	7	8	0	1
10	1	2	3	4	5	6	7	8	9	0


---------------------------------------------------------------------
ABC162 F
---------------------------------------------------------------------
奇数番目と偶数番目に分けて累積和を取っておく
偶数累積和 AE[i]
奇数累積和 AO[i]

N 偶数の時
 AE と AO の大きい方
N 奇数の時
N = 7 だと 7//2 = 3 で 3個選ぶ。4個外す

N=7
i	0123456
	.  .  .
	. .   .
	 . . . 

N=9
i	012345678
	.  . .  .
	.  .  . .
	.   . . .
	. . .   .
	. .  .  .
	. .   . .
	. .   . .


分かった
端を選択しない場合、それ以外の分の偶数部分和 と 奇数部分和 の大きい方
で、左右の端を選択しない場合は、上記で求まる。
なので、残りは左右の端を選択した場合。
A[0]を選択しているので、A[1]は自動的に外す。
A[N-1]を選択しているので、A[N-2]は自動的に外す。
なので、元の問題からは、数字の数が4減って、選択する数が2減っている。
よって、最初と同じ状況だと考えられるので、
再度、両端を外した場合を考えて、
と進めて真ん中に行くまで進めばいい

N=7
i	0123456
	._   _.
N//2 = 3 → 奇数なので、最後3つになったら、そのうち最大1つを選ぶ

N=9
i	012345689
	._     _.
	._._ _._.
N//2 = 4 → 偶数なので、最後1つになったら、もう選ぶことはない


---------------------------------------------------------------------
ABC164 E
---------------------------------------------------------------------
ワーシャルフロイドで全頂点間の最短時間を求める
時間をキーとするけど、銀貨も同時に累計しておく
で、1 → k の銀貨が S 以下なら、これが答え。
S以上なら、
両替する頂点を経由する。
両替する頂点を全部振って、時間を求めて、最短を求める
2回両替することがベストなケースがあるなら、これではNG
多分あると思う。
2回までなら、もう一回ループを回せばいいだけ？
3回はありうる？

拡張ダイクストラらしい
このネーミングが正解か実ははっきりしないらしいけど。
Aが小さいので、A最大値 * N だけあれば最短距離で目的地まで行ける。
なので、ノードの状態として、ノード番号, 現在持っている銀貨 という2つの状態を持つようにする。
ノード数 50 * A最大値 50 * ノード数 50 あるので、125000 が最大状態数
これに対してダイクストラする。

---------------------------------------------------------------------
ABC088 C
---------------------------------------------------------------------
a1 + b1 = c11
a1 + b2 = c12
a1 + b3 = c13
a2 + b1 = c21
a2 + b2 = c22
a2 + b3 = c23
a3 + b1 = c31
a3 + b2 = c32
a3 + b3 = c33

a1 + b1  a1 + b2  a1 + b3
a2 + b1  a2 + b2  a2 + b3
a2 + b1  a3 + b2  a3 + b3

---------------------------------------------------------------------
ABC165 C
---------------------------------------------------------------------
Aを総当たりする
ではなくて、Aじゃなくて、Aの差分を総当たりしたらいい？
差分の合計が M 以下


---------------------------------------------------------------------
ABC086 D
---------------------------------------------------------------------
mod(2*K) の空間にして、2次元累積和する。
K=3
	        x
	  0 1 2 3 4 5 6
	0 0 0 0|0 0 0|0
	1 0 # #|     |#
	  -----+-----+-
y	2 0    |# # #| 
	3 0    |# # #| 
	4 0    |# # #| 
	  -----+-----+-
	5 0 # #|     |#
	6 0 # #|     |#

	        x
	  0 1 2 3 4 5 6
	0 0|0 0 0|0 0 0
	  -+-----+-----
	1 0|# # #|
y	2 0|# # #|
	3 0|# # #|
	  -+-----+-----
	4 0|     |# # #
	5 0|     |# # #
	6 0|     |# # #


---------------------------------------------------------------------
ABC168 E
---------------------------------------------------------------------
AとBの比をmapのキーにする。
比なので、単純に {A,B} ではなく、通分した A と B をキーとする必要がある。
通分するには、gcd(A,B) で A と B を割ればOK
数え挙げる方法
前から順に map に保存しながら、手前にあった使えないイワシを除外したイワシの数(k)を
数えて 2^k を足していく、、、
ってやったけど NG
 j 番目まで進んだ時に、j よりも手前に使えないイワシの組がある場合、
 そのやり方では使えないイワシの組が両方 1 なパターンが含まれている。
使えないイワシの組をまとめて1グループとして扱って、そのグループ内で
どれだけの組み合わせがあるかを数える。
で、それを掛けていく。
使えない組がないなら、イワシの数だけ 2 を掛けていって 2^N になる。


---------------------------------------------------------------------
nomura2020 C
---------------------------------------------------------------------
下から計算
個数の上限下限を計算で求めていって、その後上から
	
---------------------------------------------------------------------
ABC169 E
---------------------------------------------------------------------
N奇数の場合は、中央になる値がそのまま中央値になる。
一番大きくなる場合は、Bでソートして、B(N/2) が中央値の最大
一番小さくなる場合は、Aでソートして、A(N/2) が中央値の最小
この途中の値は、証明は全然できないけど、全部実現できる気がする
問題は、N偶数の時か。
同じ考え方でいくなら、中央値生成用の2つの値が最大だったら中央値も最大なので、
一番大きくなる場合は、Bでソートして、(B(N/2-1) + B(N/2)) / 2 が中央値の最大
一番小さくなる場合は、Aでソートして、(A(N/2-1) + A(N/2)) / 2 が中央値の最小
で、これらの途中の値はどれだけ実現可能なのか？

試しに出してみる
 → 通った・・・

---------------------------------------------------------------------
ABC169 F
---------------------------------------------------------------------
部分集合の部分集合の中に合計がSになるものを数える。。。
合計がSになる部分集合を見つけたら、それが含まれる部分集合が幾つあるかを数えればいけそう
合計がSになる部分集合ってどうやって見つけるんだったっけ？
O(N^2)までは大丈夫そう
Sが3000なので、DPでいけそう

Ai の部分集合 T、Tの部分集合U で数える
DP[i][j] : i番目までの数値を使って、合計が j になる組み合わせ合計

N = 3、 S = 4
A1 A2 A3
 2  2  4

0番目（一つもない）場合の合計は 0 である場合が 1個
	[0][0] = 1

A1 を選ぶ場合
	[1][2] = 1
A1 を選ばない場合、T には含まれているけど、U には
	[1][0] = 1

 224	22	2 4	 24	2  	 2 	  4
 2  	2 	2  	 2 
  2 	 2	  4	  4
   4	
 22 	
 2 4	
  24	
	合計 19

1
	2	9
	0	10
2
	4	3
	2	12
	0	4
3
	8	1
	6	4
	4	6
	2	8
	0	0

---------------------------------------------------------------------
AGC045 A
---------------------------------------------------------------------
人0が最終的に0にしたいので、最後に操作するのは基本的に人0である必要がある。
例外は、最後の人1用のAiがすべて 0 である場合のみ。
おしりから考えて、人0の操作群で 0 にすることができる or できない数値たちを求める。
人1は先頭から作ることがでできる数値たちを求める。
先頭からとお尻からで可能な値の範囲を変更しながら進んでいけはいい？
その範囲ってどうやって表現する？
Ai が 10^18 あるので、値列挙は不可能。
bit単位の表現もできない。
 例えば 最後の0操作が 0110 と 0001 だった場合
 0000, 0001, 0110, 0111 なら 0 にできる。
 0100 は不可。
 なので 0*** だったら、という表現は不可。
0群のXORで作れる可能性がある値なら OK なのか。
けど N 最大が200なので、そのまま求めようとすると O( 2^200 ) 必要になる。
 2^200 = 2^(20*10) = 10^(20*3) = 10^60
なので当然NG

ある値をもとにXORを取っていって 0 になるか求めるなら、
掃き出し法が使える。


---------------------------------------------------------------------
tokaimarine2020 
---------------------------------------------------------------------


---------------------------------------------------------------------
ABC171 F
---------------------------------------------------------------------
K文字の文字列の数は 26^K
K文字列の途中に、Sを入れると考えると、その組み合わせ数は COM( K+S, S )
それらを掛け合わせると総合計は出るが、同じ文字列が含まれる

oof に 1文字入れるという問題だとすると、
 o o f
o
 o o f
  o
 o o f
    o
は同じ
 o o f
    f
 o o f
      f
も同じ

---------------------------------------------------------------------
ABC172 E
---------------------------------------------------------------------
1 以上 M 以下の整数からなる長さ N の数列 A1,A2,...,AN と B1,B2,...,BN の組であって、
以下の条件をすべて満たすものの個数を求めてください。
  1 <= i <= N なる任意の i について Ai≠Bi
  1 <= i <= j <= N なる任意の (i,j) について Ai≠Aj かつ Bi≠Bj
ただし、答えは非常に大きくなる可能性があるので、(10^9+7) で割ったあまりを出力してください。

Ai (i=0～N-1) な数列で、Ai != i な数列を完全順列とか攪乱順列とかいうらしい。
その数え上げ問題
で、包徐原理というのを使うらしい。
Ai と Bi のうち j 個数値が等しいものを考えると、
j=0	





---------------------------------------------------------------------
ABC172 E
---------------------------------------------------------------------
  // A = 1,2,3,..,N に固定して考える
  // B の組み合わせ数は何も条件がないなら PER(M, N)
  // 少なくとも i 個の A と B が一致している場合は、PER(M-i, N-i)
  // i 個の一致がある場合の組み合わせは COM(M, i)
  // 包徐原理で i 奇数は引く、偶数は足す
  //  i=0 の場合は、全条件不定なので全事象の数になるので ＋ 
  //  i=1 の場合を上記全事象から引くので  ー
  // 固定していた A の組み合わせ数は PER(M ,N)

---------------------------------------------------------------------
ABC083 D
---------------------------------------------------------------------
解説見た
S[i] と S[i+1] が異なる場合、S[0:i+1] か S[i+1:N] を反転したら、
異なる点は無くなる。その操作では、それ以外の部分に関しては0/1の違いの点は変わらない。
よって、上記操作の S[0:i+1] か S[i+1:N] の長い方が、答え K の候補となる。
で、S全体に上記操作による K 候補を出して、その中の最小値が答え
 → WA
全部 0 とか 全部 1 の時に対応できてないか。
全部 0 にするのが目的なので、0 なら反転の必要なしだけど、答えは最大のKなので、
|S|が答えになるはず。


---------------------------------------------------------------------
ABC173 E
---------------------------------------------------------------------
N==K の場合
	選択の余地なく、全項目掛けるだけ
Aiが全部負の数で、Kが奇数の場合
	結果が負の数になるので、絶対値が小さいのをK個選ぶ
それ以外
	残り一つまで絶対値が大きいのを選ぶ
	正の場合
	  次に絶対値が大きい正の数を選ぶ
	  残りが全部負の場合は？
	    残りの負の数から2つを選んで、最後の正の数を割る必要がある。
	    正の数も、戻せるようするか、残り二つまで選んだあとの判定にするか？
	     残り二つにしても、負の数で、残り全部が正ならやっぱり同じか。。
	負の場合
	  次に絶対値が大きい負の数 と
	  選んだ中で一番絶対値が小さい負の値を抜いて、次に絶対値が大きい正の数を
	  2つ選んで掛けたものと、どっちが大きいか比較して、大きい方を選ぶ
	  負の値は2個セットで初めて全体の値にかけることにする。
	  1個だけの状態で、残り一つまで来たら、その1個を使って上記比較をする

	正の数は1個、負の数は2個セットで数えていく方法を考えてみる。
	Ai を見ていくポインタとは別に現在何個選んでいるかのカウンタを用意。
	そのカウンタが K まで行ったら終了？
	
	K個選ぶ方法で実装してみる
	K個とりあえず選ぶ。その時に、正の数の個数を覚えておく。
	結果が正の数なら、それが答え。
	負の数なら、以下のどちらかをする。
	・正の数を1個除いて、次に大きな負の数を加える
	・負の数を1個除いて、次に大きな正の数を加える
	このためには最後に加えた、正の数、負の数を覚えておくだけでOKかも？
	
	1個除くという処理を mint を導入して割り算にしてみる。
	 うまくいかない？
	 そうか、、、MOD空間で大小比較しても意味がない！

---------------------------------------------------------------------
M-SOLUTIONS プロコンオープン 2020 D
---------------------------------------------------------------------
谷底で全部買って、山頂で全部売るのがベストなはず
最後がちょっと特別
最後が昇りなら最終日に売る
最後が下り坂なら、、、その時に株は持ってないはず


---------------------------------------------------------------------
M-SOLUTIONS プロコンオープン 2020 E
---------------------------------------------------------------------
一次元で考えて見る
距離を縮めたい点集合の平均位置に線路を引けば、線路との距離の合計は一番小さくなる
正確には、その平均位置から一番近い点までの範囲ならば、どこでもOK
その点の集合はどうやって求める？
あ、集落の数は N なのか。。。
最大 15

N==K の時は明らかに、各集落を通るように引けば最小

線路は必ず各集落の上を通るようにすると仮定すると、
線路の位置の候補は 30


---------------------------------------------------------------------
ABC174 C
---------------------------------------------------------------------
3*9 = 27
7*1 = 7

	        131
	        abc
	        ---
	       1017	7
	       986	6
	     1179	9
	       0	0
	    986	6
	  1048	8
	  524	4
	 655	5
	  6	5
	   777777777

77.. % D = 0 を探す

7 % D
77 = 7 * 10 + 7
 77 % D = (7%D) * (10%D) + (7%D)
777 = 77 * 10 + 7
 777 % D = (77%D) * (10%D) + (7%D)

7%101 = 7
10%101 = 10
77%101 = 7*10+7 = 77
777%101 = 77 * 10 + 7 = 777 % 101 = 70
7777%101 = 70 * 10 + 7 = 707 % 101 = 0

---------------------------------------------------------------------
ABC174 D
---------------------------------------------------------------------
W の個数を数えて、右からその個数分の石の中に、R が何個あるか調べたらいいだけ？
N = 5
 0 1 2 3 4
 W W R W R

WWWR
RWWW
WRRW

---------------------------------------------------------------------
ABC174 E
---------------------------------------------------------------------
できるだけ同じ長さにしたい
最終的には N + K 本の丸太になる
長さの合計は変わらないので、
Lall / (N+K)
がベストの値

例1
7 と 9 を3回切る
合計 16
最終丸太は 5本
16/5 = 3.2 
がベスト
7 / 3.2 = 2 ... 0.6
9 / 3.2 = 2 ... 2.6

にぶたんらしい！
なるほど
やっぱり蟻本買うべきか

---------------------------------------------------------------------
ABC174 F
---------------------------------------------------------------------
set を使ったセグ木を組めば行けそうな気がする。
update時には、上に遡りながら、追加した個所の色を set にinsertしていく。
取得時には、、、
 範囲内の各setを全部マージして、最終的に集まったsetの要素数を数える。
全部色が違うとして、クエリがだいたい全体を指定ばっかりだったとすると、
計算量が Q * N * logN になるので間に合わない？
取得が O(NlogN) と遅いのが難点か。
できれば O(1) にしたい。せめて O(logN)


---------------------------------------------------------------------
ABC081 D
---------------------------------------------------------------------
解説見た
なるほど、正の数だけなら累積和的に順番に足すと、条件を満たせる。
負の数だけの場合も同様。
その時の演算回数はN-1回
ここまでは何となくは浮かんでた。
混ざっているときにどうするかか問題だった。
2N回までできるので、後N回は演算できる。
なので、一番大きい数の絶対値 と 一番小さい数の絶対値を比較して、
絶対値が大きい方の数字を全項に加算したら、全部正 or 全部負 になる。
なるほどなあ

---------------------------------------------------------------------
AGC047 A
---------------------------------------------------------------------
整数 * 整数 は整数
小数 * 小数 は小数
小数 * 整数 が問題
小数を分数表記にして約分した時の分母の数字が、掛ける対象の整数の約数なら整数になる。
なので、小数を分数表記
	0.75 なら 75 / 100 として、75 と 100 の最大公約数を求めて、100 / GCM する。
整数は約数を求めて、mapに格納
分母でそのmapを引いて、その数がその小数と掛けると整数になる数の数

小数 * 小数 も整数になる・・・
7.5 * 2.4 = 18
7.5 = 75 / 10 = 15 / 2
2.4 = 24 / 10 = 12 / 5
分子が相手の分母の倍数が両側で成り立つなら整数になる

間違い！

どうやら、全部 10^9 倍してから考える。
そうすると、積が整数ということは、10^18 が約数として存在しているということになる。
で、10 は 2*5 なので、積の素因数分解で 2 が 18 個以上、5 が 18個以上存在する。
積がそうなるってことは、元の2つの数それぞれ素因数分解した場合に、その素因数 の
2 の個数と 5 の個数の合計が18以上になる2つの数を見つけたらいい。

素因数分解して、


---------------------------------------------------------------------
ABC176 D
---------------------------------------------------------------------
単純にグラフ作ってダイクストラ？
と思ったらWA＆TLE
TLEはまだわかる。多分、辺が多すぎる
辺の総数のMAXは1000*1000*25 で 2*10^7
なのでTLEなのは納得
WAはなんで？

BFSで作れる気がする。
まずは原点から


---------------------------------------------------------------------
ABC177 E
---------------------------------------------------------------------
全部素因数分解して、素因数をカウントする。
素因数個数がすべて 1 以下なら、pairwise coprime 
個数が N な素因数があれら、setwise coprime 
といえる気がする
素因数分解にかかる時間は √N なので、間に合う？？

---------------------------------------------------------------------
ABC177 F
---------------------------------------------------------------------

1	....
	 ---
2	....
	-   
3	....
	 -- 
4	....
	 ---
5	....

H,W は 2*10^5 なので、単純に BFS では間に合わないはず
DFS にする必要がある？
DFSでk階に最初に到着した場合のステップ数が、必ず答えになる。


左をふさがれると、それより下の行では、それよりも左に行くことができなくなる。
なので、左につながっている壁は下方向にORしていく感じで。

---------------------------------------------------------------------
ABC178 C
---------------------------------------------------------------------
0,9,x
9,0,x
0,x,9
9,x,0
x,0,9
x,9,0

---------------------------------------------------------------------
ABC178 D
---------------------------------------------------------------------
N/3 切り上げが最大項目数
合計がSになる数列の組み合わせは、項目数Nとして、
 COM(S+N-1, N-1)
となる
合計値5 で項目数 3 だとすると
	||ooooo
の区切り位置を選ぶ数なので、こうなる

---------------------------------------------------------------------
ABC178 F
---------------------------------------------------------------------
同じ値が半分以上あればNo
どうやってBを作るか
1 1 2 2 3
2 2 1 1 

---------------------------------------------------------------------
ABC179 D
---------------------------------------------------------------------
遅延セグ木を使って提出したけど、ぎりぎり
多分想定解ではない

解説見た
imos法
imos法でやっても、毎回評価するから O(N^2) なんでは？
違った。。。
左から順に処理するので、それより右の位置で発生するクエリによって
現在位置の値が変化することはない。
加算区間の途中では？
 途中の位置を処理するときには、それより左にある区間開始位置を必ず通っていて、
 そこで加算されている。

N=5
1 1
3 4
	i	1  2  3  4  5  6  7
	1	1  0  0  0  0  0  0
	1	1  1 -1  1  0 -1  0	配り終わった
	2	
	2	1  1 -1  1  0 -1  0	配り終わった

	i	1  2  3  4  5  6
	1	1  0  0  0  0  0
	1	1  1  0  1  1  0	配り終わった
	2	1  1  1  1  2  1	配り終わった
	3	1  1  1  2  2  2	配り終わった
	4	1  1  1  2  4  2	配り終わった

	i	1  2  3  4  5  6
	0	1 -1  0  0  0  0
		   1    -1
	1	1  1  1  0  0  0
		      1    -1
	2	1  1  2  1  0  0
		         2    -2
	3	1  1  2  3  2  0
		            3    -3
	4	1  1  2  3  5  3

分かった！
imos法での累積を同時に行っていくには、一番最初のdp[1]だけが 1 な状態の
場合が問題なのか。
ここだけ実際の値が入っていてimos法の値ではない！
処理としては全部imos法的な値のセット方法をしている前提なので、
1番目だけが 1 だと、それ以降もずっと 1 であるという意味になる。


---------------------------------------------------------------------
ABC179 E
---------------------------------------------------------------------
(X + X^2 + X^4 + X^8 + ...) % MOD
という和の計算になる
公式があるのかと思ったけど、違った。
Mが 10^5 以下なので、どこかでループすることになる。
そのループを発見するまでには、最大でも M 回の演算なので間に合う。

[0] - [1] - [2] - [3] - [4]
             |           |
             +-----------+
とする。
各項の値をベクタに保存する。
map キーは各項の値、val はその登場アドレス
とすると、val == 0 をその値がまだ出てきてない場合に使いたいので、
[1] - [2] - [3] - [4] - [5]
             |           |
             +-----------+
とする。
1.値計算
2.mapで同じのがあるか確認
3.無ければ、
	ベクタAに値を追加
	累積和にしておくと便利そう？
 あれば
	ループに入るアドレス lp
	ループの項目数 ln
4. 計算
	l = N - lp -1		ループ以降の部分の数
	l / ln		ループ回数
	l % ln		最後のループのあまり
	

---------------------------------------------------------------------
ARC106 B
---------------------------------------------------------------------
合計は変わらない
直感的には合計が一緒ならいける
全部つながってないことがあるのか、、、
ならば、UnionFindでまとめて、グループの合計を計算し、全部一致すればOK

---------------------------------------------------------------------
ARC106 C
---------------------------------------------------------------------
多分高橋君の方法は正しい結果がでる。
青木君は
	+----------------+
	  +--+  +--+  +---+ 
こんなんだと、1個となるけど、
高橋君だと
	  +--+        
	        +--+ 
	+----------------+
	              +---+ 
となって、3個という答えになる
M = 2
[1:4+M*2]
[2:3]
[4:5] 3+i,3+i+1
[6:7] 3+2i,3+2i+1

---------------------------------------------------------------------
ARC107 A
---------------------------------------------------------------------
2 3 4
a b c
1 2
1 2 3
1 2 3 4

(1 2 3) + 2(1 2 3) + 3(1 2 3)
(1/2 * a * (a+1))
(1/2 * a * (a+1))
A + 2A + 3A
1/2(A+BA)

---------------------------------------------------------------------
ARC107 B
---------------------------------------------------------------------
(a+b) - (c+d) 
ab - cd = K
ab >= (K+2)
2+K ... 2N

6  1 5, 4 2, 3 3, 2 4, 5 1
5  1 4, 2 3, 3 2, 4 1
4  1 3, 2 2, 3 1
3  1 2, 2 1
2  1 1


---------------------------------------------------------------------
ARC107 C
---------------------------------------------------------------------
i行目の最小のAを min(A(i))とすると、K-min(A(i)) 以下の A(i,n) の列が入れ替え可能
1
3
5
K=6 だとすると、3と5は直接入れ替え不能だけど、1-3、1-5 と1を経由すれば可能

間違えた
すべての列で、A(i,x) + A(


---------------------------------------------------------------------
ABC182 D
---------------------------------------------------------------------

2 -1 -2

累積和
2 1 -1

累積和の累積和
2 3 2


2		2	2
2 -1		1	3
2 -1 -2		-1	2

1 2 3 -1
1		1	1
1 2		3	4
1 2 3		6	10

---------------------------------------------------------------------
ABC183 E
---------------------------------------------------------------------
1 1 2
1 # 3
2 3 10
DPで
現在のマスの縦方向合計（自分含む）を計算する
横、斜めも同様


---------------------------------------------------------------------
ARC109 B
---------------------------------------------------------------------
n+1 を1～nまでの異なる数の和で、その数の個数が一番多くなる方法

3	1+3,		2
4	1+3,		2,4
5	1+2+3,		3,4
6	1+2+3,		4,5,6
7	1+2+3,		4,5,6,7
8	1+2+3,		4,5,6,7,8
9	1+2+3+4,	5,6,7,8,9


---------------------------------------------------------------------
ARC109 C
---------------------------------------------------------------------
愚直だと、2^k-1 回の判定が必要になる
n奇数が面倒なので、n2倍して偶数にする
win[i][j] 
 i ： 開始位置 % 2n
 j ： 大会参加者数が2の何乗か
という配列を作る
最大でも 200*100 = 20000 個
win[i][j] = janken( win[i][j-1], win[i+2^(j-1)][j-1] )
でわかる

---------------------------------------------------------------------
ABC184 D
---------------------------------------------------------------------
期待値DP

---------------------------------------------------------------------
ABC186 D
---------------------------------------------------------------------
5 1 2
5 1
5   2
  1 2
4 + 3 + 1 = 8

1 2 5
 1 3 = 4
   3

1 2 5 6
 1 3 1 = 5

1 2
1   5
1     6

1     6
  2   6
    5 6
0 1 2 3	i

---------------------------------------------------------------------
ABC186 E
---------------------------------------------------------------------
          N
....o.....|....o.....|....o.....|....o.....|
       t    K    K    K    K    K    K
    |  |
      S
          N
o.........o.........o.........o.........
   t    K    K    K    K    K    K
|  |
   S

	Kx + S = 0 (mod  N)
	Kx = -S (mod N)

K と N が互いに素なら K * K^(-1) = 1(mod N) となる逆元が存在する
	x = - K^(-1) S (mod N)

K と N が互いに素でないなら、
	Kx = -S (mod N)
	Kx + S = Ny
g = GCD(K,N) とすると、
	S = Ny - Kx = g(ny - kx)
なので、S も g の倍数である必要がある。

倍数でなければ、Kx = -S (mod N) は満たさない。→ 解なし
倍数なら、
	Kx + S = Ny
	gkx + gs = gny
	kx + s = ny
	kx = -s (mod n)
となって、KとSとNを g で割った数字で新たに式を作る

---------------------------------------------------------------------
ABC187 D
---------------------------------------------------------------------
0
a	sum(A)
t	0

a	sum(A) - a[i]
t	a[i] + b[i]

差分	sum(A) - 2a[i] - b[i]
2a[i] + b[i] が大きい順にソートして順番に取っていく

---------------------------------------------------------------------
ABC187 E
---------------------------------------------------------------------
辺を双方向で別々に管理。
加算値を累積していく
一度累積したら、その辺のその方向は使用済みとマークする
辺が1個の全部の頂点から累積する
 → NG！
    辺が1個の頂点多すぎ
    ある頂点から加算後、別頂点からの加算を行う必要があるので、
    使用済みの辺であっても、そこで探索を終えることはできない

探索が1回で終わるように何とかする必要があった
片方のみに加算、ではなく、全体に加算し反対側は減算とする。
探索開始位置に近い側に加算の場合
	全体に加算
	辺にマイナスする値セット
探索開始位置から遠い側に加算の場合
	辺にプラスする値セット
遠いか近いかを判定する必要あり？
 いや、辺の情報にどっち側の値化を保存しておけば、探索しながら計算できそう

---------------------------------------------------------------------
ABC188 D
---------------------------------------------------------------------
単純に配列を確保すると、GBを超えてしまう・・
単純なimos法は使えない
配列に、加算日と減算日を積む

---------------------------------------------------------------------
ABC188 E
---------------------------------------------------------------------
自分に向かう道が無くて、出ていく道がある町から開始
探索しながら、最小値も積む

BFSでTLE・・・
ダイクストラで、現在の最小値が小さい順に積む



---------------------------------------------------------------------
keyence2021 B
---------------------------------------------------------------------
0からのシーケンスを作れるだけ作って、その最後の数+1を合計する
カウントして、
0個数	2
1個数	1	1
2個数	1
3個数	0	1

0個数	1
1個数	2
2個数	1
3個数	1
4個数	0	1
最小値を管理して、それよりも小さくなった数

6 4
0 1 2 0 0 1

8 4
0 1 2 0 0 1 0 1
8 2
0 1 2 0 0 1 0 1

---------------------------------------------------------------------
keyence2021 C
---------------------------------------------------------------------
2 2 3
1 1 X
2 1 R
2 2 R
	X *
	R R
ゴールから手繰っていくべき
* を通らなかったルートの総数*3 を加算
	X * *
	R R R

	8 5 2
	1 1 0

	X  * X/D
	D  * X/D
	R  R 
	
	19 4
	5  2
	1  1

解説見た
普通に先頭からでいいみたい



---------------------------------------------------------------------
ABC189 D
---------------------------------------------------------------------
Sn = AND なら
Yn = Yn-1 && Xn = 1 の場合
Xn と Yn-1 は必ず 1

Yn = Yn-1 && Xn = 0 の場合
Yn-1 = 0 なら、Xn は 0 or 1
Yn-1 = 1 なら、Xn は 0


Sn = OR なら
Yn = Yn-1 || Xn = 1 の場合
必ず Xn && Yn-1 != 0 
Xn = 0 なら、Yn-1 は 1
Xn = 1 なら、Yn-1 は 0/1 どっちもOK

Yn = Yn-1 || Xn = 0 の場合
Xn = Yn-1 = 0 のみ


n    0    1    2
Yn0  1    3    3
  1  1    1    5
      AND   OR

---------------------------------------------------------------------
ABC189 E
---------------------------------------------------------------------
op1
	(1,2) -> (2,-1)
	(2,-1) -> (-1,-2)

---------------------------------------------------------------------
ABC191 C
---------------------------------------------------------------------

*#.
.##	1
*##

*#.
.##	2
*#.

*.*
.##	2
*#.

*.*
.##	1
*##

###
###	1
.##

##.
###	2
.##

...
.#.	２追加
*#*

5 8
........
.#.#....
.#.####.
.###.##.
........

6 8
........
..###...
.##.##..
.#...#..
.##.##..
........

3 3
...
.#.
...



---------------------------------------------------------------------
ARC112 A
---------------------------------------------------------------------
2 6
a+b=c
c最大は6
6-2=4
なので 2～4 の個数が6の時の個数 3

C=5の場合
5-2 = 3
2 ～ 3 の個数が 5 の時の個数 2

2 5 の場合
5 = 2 + 3
5 = 3 + 2
4 = 2 + 2

5 6 の場合
なし

3 6 の場合
6 -3 = 3
6 = 3+3

4 7 の場合
7 -4 = 3
4～3なのでなし

---------------------------------------------------------------------
ARC112 B
---------------------------------------------------------------------
11 2
11 - 2/2
          0
----------+-----------
  -B         a      B
          0
----------+-----------
A   -B    a     B

          0
----------+-----------
      a       -a   B

          0
----------+-----------
      a     B -a
(abs(a)-1) * 2 + 2 

          0
----------+-----------
      a   B  -a

          0
----------+-----------
    a   B

       -2 0
----------+-----------
        a B
-1 と 1	abs(a-1)*2
0	+1
-2	+1


              0
--------------+---------------
  ---b---          ---B---
(C-1)/2 (C-1)/2   C/2   (C-2)/2

              0
--------------+---------------
  ---B---          ---b---
C/2   (C-2)/2   (C-1)/2  (C-1)/2

2 5
0 1 2 3
-4 -3 -2 -1




100000000000000000000000000000000000000000000000000000000000
999999999999999999999999999999999999999999999999999999999999
1000000000000000000

<<<<<<< HEAD
---------------------------------------------------------------------
ABC192 E
---------------------------------------------------------------------
ダイクストラ
次の頂点に行くまでの時間として、”辺の時間 ＋ 次の電車までの待ち時間”を使えばOK

priority_queue のデフォルトが降順なので、ダイクストラに使うには昇順にする必要あり。

次の電車までの待ち時間は、初めは↓のように書いてたけ。
これでコンテスト中は通るみたいだけど、after_contest パターンが追加されていて、それではTLEになる。
割り算を2回しているのがだめっぽい
 nnt = tim[city] + nt + (nk - (tim[city]%nk)) % nk;
	↓
 nnt = nt + (tim[city]+nk-1)/nk*nk;
これなら通る

 ll timmod = tim[city]%nk;
 nnt = tim[city] + nt + (nk - ((timmod == 0) ? nk : timmod));
これなら？
 → 通った！
    時間もほとんど変わらんかったので、割り算回数が問題なんだな、やっぱり

  priority_queue< pair<ll, int>, vector< pair<ll, int> >, greater< pair<ll, int> >  > q;
  q.emplace(0,X);
  tim[X] = 0;
  while( !q.empty()) {
    auto v = q.top(); q.pop();
    int city = v.second;
    if (city == Y) {
      return tim[Y];
    }
    for( auto nv : to[city] ) {
      int ncity; ll nt,nk,nnt;
      tie(ncity, nt, nk) = nv;
      nnt = nt + (tim[city]+nk-1)/nk*nk;
      if ( tim[ncity] <= nnt ) continue;
      tim[ncity] = nnt;
      q.emplace(nnt, ncity);
    }
  }
=======

---------------------------------------------------------------------
ABC193 D
---------------------------------------------------------------------
全パターンあたる
勝ちの場合の自分枚数*相手枚数を勝ち箱に入れる。
負けも同様。
最後に確立を計算する

---------------------------------------------------------------------
ABC193 E
---------------------------------------------------------------------

 B         A B         A
---o---o---o---o---o---o---o---o
>>>>>>> refs/remotes/origin/master


---------------------------------------------------------------------
ABC194 C
---------------------------------------------------------------------

(A1 - A2)^2 = A1^2 + A2^2 - 2A1A2
(A1 - A3)^2 = A1^2 + A3^2 - 2A1A3
(A2 - A3)^2 = A2^2 + A3^2 - 2A2A3
(A1^2 + A2^2 + A3^2) * 2 - 2 *( A1A2 + A2A3 + A1A3)

---------------------------------------------------------------------
ABC194 D
---------------------------------------------------------------------
i : 到着している数
dp[i] = dp[i] * i/N + dp[i-1] * (N-i)/N + 1
dp[i] - dp[i] * i/N = dp[i-1] * (N-i)/N + 1
dp[i] (1 - i/N ) 
dp[i] (N-i)/N
dp[i] = dp[i-1] + N/(N-i)

---------------------------------------------------------------------
ABC194 E
---------------------------------------------------------------------
110	2:3
010	0:1 2:3

1001	1:3
^
0001	0:3

1101	2:3
^
0101	0:1, 2:3

00110	0:2, 4:5
  ^
00010	0:3, 4:5

0010	0:2, 3:4
  ^
0000	0:4

条件が無駄に複雑
解説見た
なるほど、、、全体の最小値を求めるんだから、mexの最小値のみを記録していけばいいのかあ、、、
途中で mex が大きくなることもあるけど、その時をわざわざ追いかける必要がないってことか・・・

---------------------------------------------------------------------
ABC196 D
---------------------------------------------------------------------
ドミノ詰め問題の変形らしい
16*16 = 256
bit DP
間違い、
H*W の 最大 が 16 だった。
	x  1 0  y
	   . .  0
	   . .  1
(0,0) から開始
	半畳
	一畳を横
	一畳を縦
の3パターンでDPを更新していく。
処理している行の状態を bit で管理
畳を置いた枚数でも管理する。
で、残り面積 > 残り畳合計面積 なら、そのような状態は無いので加算しない

最終結果は、最後のマスの次のマス、つまり(0,H) にて畳枚数が A で bit が 0 
なDPが答え

解説を見ると、DFSでも求まるらしい。。。
最大でも16マスしかないので、
	3^16 = 43046721 -> 4 * 10^7
で間に合うらしい。
ちょっとぎりぎりだけど、実際は成り立たないパターン（畳が重なる）がたくさんあるので、
十分にまにあうらしい。

---------------------------------------------------------------------
ABC196 E
---------------------------------------------------------------------
f(x) = min(c, max(b, x+a))
という形になって、それを連ねていくらしい
g(f(x)) = min(C, max(B, x+A))
という形に変形したい
g(f(x)) = min(c, max(b, min(f, max(e, x+d))+a))
= min(c, max(b, min(f+a, max(e+a, x+d+a))))

max（a、min（b、c））= min （max（a、b）、max（a、c））
min（a、max（b、c））= max（min（a、b）、min（a、c））
らしい
min（a、max（b、c）を考える
	a > b > c	b
	a > c > b	c
	b > a > c	a
	b > c > a	a
	c > a > b	a
	c > b > a	a
確かに成り立っている

g(f(x)) = min(c, max(b, min(f, max(e, x+d))+a))
= min(c, max(b, min(f+a, max(e+a, x+d+a))))
= min(c, max(b, max(min(e+a,f+a), min(x+d+a,f+a))))

	max(x, max(y,z)) = max(x,y,z) なので

= min(c, max(b, min(e+a,f+a), min(x+d+a,f+a)) ))
変形の方針ちょっと間違っている？

g(f(x)) = min(c, max(b, min(f, max(e, x+d))+a))
= min(c, max(b, min(f+a, max(e+a, x+d+a))))
= min(c, min(max(b,f+a), max(b, max(e+a, x+d+a)) ) )
= min(c, max(b,f+a), max(b, e+a, x+d+a) )
	C = min(c, max(b,f+a))
	B = max(b, e+a)
	A = d+a
	とすれば
= min(C, max(B, x+A))

d = a0, e = b0, f = c0 と記載する
C = min(c, max(b,c0+a))
B = max(b, b0+a)
A = a0+a
 t = 1 の場合は、b = -INF, c = INF なので、
	C = c0+a
	B = b0+a
	A = a0+a
 t = 2 の場合は、a = 0, c = INF なので、
	C = max(b, c0)
	B = max(b, b0)
	A = a0
 t = 3 の場合は、a = 0, b = -INF なので、
	C = min(c, c0)
	B = b0
	A = a0

---------------------------------------------------------------------
ABC198 D
---------------------------------------------------------------------
条件から、出てくる文字は10文字しかないはず
全パターン網羅で 10! = 3628800 なので間に合う


---------------------------------------------------------------------
jsc2021 C
---------------------------------------------------------------------
最大公約数の最大値
互いに素なら、1 にしかならない
答えを振って、考える？
最大値は、大きい側の数の半分

---------------------------------------------------------------------
jsc2021 D
---------------------------------------------------------------------
A1 が P 倍数である個数
	0
	A1 は 最大でも P-1 のため
A1+A2 が P 倍数である個数
	最大でも P。 2P にはならない
	1 ～ P-1 なので、
	P=2 だとすると  1 1 の1つ
	P=3 だとすると  1 2, 2 1 の2つ
	P=4 だとすると  1 3, 2 2, 3 1 の3つ
	P=5 だとすると  1 4, 2 3, 3 2, 4 1 の4つ
	P-1 個ある
	P-1 * (P-1)^(N-2)
	 = (P-1)^(N-1)
A1+A2+A3 が P 倍数である個数
	最大でも 2P。 3P にはならない
	合計値P
	P=2 だとすると  0個
	P=3 だとすると 1 1 1 の 1個
	P=4 だとすると 1 1 2、1 2 1, 2 1 1 の 3個

	合計値2P
	P=2 だとすると 1 1 2、1 2 1, 2 1 1 の 3個
	P=3 だとすると 1 1 4, 1 2 3, 1 3 2, 
	P=4 だとすると 1 1 2、1 2 1, 2 1 1 の 3個
	C(P-i+i-1, i-1) + C(2*P-i+i-1, i-1) 
	= C(P-1, i-1) + C(2*P-1, i-1) 
	に (P-1)^(N-i) を掛ける

	( C(P-1, i-1) + C(2*P-1, i-1) ) * (P-1)^(N-3)
	= ( (P-1)(P-2)/2 + (2P-1)(2P-2)/2 ) * (P-1)^(N-3)
	= (P-2)(P-1)^(N-2) + (2P-1)(P-1)^(N-2)
	= (3P-3)(P-1)^(N-2)
	= 3(P-1)^(N-1)

A1+A2+A3+A4 が P 倍数である個数 i=4
	( C(P-1, 3) + C(2*P-1, 3) + C(3*P-1, 3) ) * (P-1)^(N-4)
	= ((P-1)(P-2)(P-3)/(3*2) + (2P-1)(2P-2)(2P-3)/(3*2) + (3P-1)(3P-2)(3P-3)/(3*2)) * (P-1)^(N-4)
	= ((P-1)(P-2)(P-3)/(3*2) + (2P-1)(2P-2)(2P-3)/(3*2) + (3P-1)(3P-2)(3P-3)/(3*2)) * (P-1)^(N-4)

解説見た
素直に、P 倍数じゃない個数を数えていけばよかったらしい。。。。。


---------------------------------------------------------------------
ABC199 D
---------------------------------------------------------------------
     ---------
     |       |
 1 - 2 - 3 - 4
 |       |   |
 ---------   |
 |           |
 -------------

---------------------------------------------------------------------
zone2021 C
---------------------------------------------------------------------
5つのパラメータの最大値の最小値が答え？
 → WA
最大値を持つのがばらばらの5人なら、そうは行かない

全部上げて確認するのは、C(3000,3) = 4495501000
なので TLE
誰か1人を確定できれば C(2000,2) になって確認できる

	1 1 6 1 1 
	1 1 1 6 1 
	1 1 1 1 6 
	5 0 0 0 0
	1 6 1 2 2 
	3 3 3 3 3 

---------------------------------------------------------------------
zone2021 E
---------------------------------------------------------------------
解説見た
基本的にはダイクストラでOK
下に降りるときに工夫が必要
	
〇
	↓  2
	〇
	  ／ 3
	〇
	  ／ 4
	〇

最初に下に行くときだけ ＋1 多めにすれば、それより下にはコスト1の辺があればいい
最初だけ +2
途中点を増やす

		〇
	 2	↓
		＊ --+
	 0	↓   | 1 
		〇   |
	 2	↓   |
		＊ --+
	 0	↓   |
		〇   | 1
	 2	↓   |
		＊ --+
	 0	↓
		〇

---------------------------------------------------------------------
ABC202 D
---------------------------------------------------------------------
最大
30と30で
C(60,30)
30 30 118264581564861424
サンプル見たら、最大が書いてあった
64bitには収まるみたい

000111	1	C(2,2)
001011	2
001101	3	C(3,2)
001110	4
010011	5
010101	6
010110	7	C(4,2)
011001	8
011010	9
011100	10
100011	11

上の桁から順に確定させる
最上位が 0 の場合の数は、C( a+b-1, b)

c(5,3) = 5*4*3/2/3 = 10


---------------------------------------------------------------------
ARC122 A
---------------------------------------------------------------------
a,b の場合
	a + b
	a - b
 +	2   1
 -	0   1
の2つ
a,b,c の場合
	a + b + c
	a - b + c
	a + b - c
 +	3   2   2
 -	0   1   1
の3つ
a,b,c,d の場合
	a + b + c + d
	a - b + c + d
	a + b - c + d
	a + b + c - d
	a - b + c - d
 +	5   3   4   3
 -	0   2   1   2
の5つ
a,b,c,d,e の場合
	a + b + c + d + e
	a - b + c + d + e
	a + b - c + d + e
	a + b + c - d + e
	a + b + c + d - e
	a - b + c - d + e
	a - b + c + d - e
	a + b - c + d - e
 +	8   5   6   6   5
 -	0   3   2   2   3
の8つ
a,b,c,d,e,f の場合
	a + b + c + d + e + f
	a - b + c + d + e + f
	a + b - c + d + e + f
	a + b + c - d + e + f
	a + b + c + d - e + f
	a + b + c + d + e - f
	a - b + c - d + e + f
	a - b + c + d - e + f
	a - b + c + d + e - f
	a + b - c + d - e + f
	a + b - c + d + e - f
	a + b + c - d + e - f
	a - b + c - d + e - f
 +	13  8  10   9  10   8
 -	0   5   3   4   3   5
の13
1個増えるたびに、ひとつ前の全パターン数と、ひとつ前のAの+個数の合計が増えていく
これで計算可能だけど、O(N^2)になる
a,b,c,d,e,f,g の場合
	a + b + c + d + e + f + g
	a - b + c + d + e + f + g
	a + b - c + d + e + f + g
	a + b + c - d + e + f + g
	a + b + c + d - e + f + g
	a + b + c + d + e - f + g
	a - b + c - d + e + f + g
	a - b + c + d - e + f + g
	a - b + c + d + e - f + g
	a + b - c + d - e + f + g
	a + b - c + d + e - f + g
	a + b + c - d + e - f + g
	a - b + c - d + e - f + g
	a + b + c + d + e + f - g
	a - b + c + d + e + f - g
	a + b - c + d + e + f - g
	a + b + c - d + e + f - g
	a + b + c + d - e + f - g
	a - b + c - d + e + f - g
	a - b + c + d - e + f - g
	a + b - c + d - e + f - g
 +	21 13  16  15  15  16  13
 -	0   8   5   6   6   5   8

a,b,c,d,e,f,g,h の場合
	a + b + c + d + e + f + g
	a - b + c + d + e + f + g
	a + b - c + d + e + f + g
	a + b + c - d + e + f + g
	a + b + c + d - e + f + g
	a + b + c + d + e - f + g
	a - b + c - d + e + f + g
	a - b + c + d - e + f + g
	a - b + c + d + e - f + g
	a + b - c + d - e + f + g
	a + b - c + d + e - f + g
	a + b + c - d + e - f + g
	a - b + c - d + e - f + g
	a + b + c + d + e + f - g
	a - b + c + d + e + f - g
	a + b - c + d + e + f - g
	a + b + c - d + e + f - g
	a + b + c + d - e + f - g
	a - b + c - d + e + f - g
	a - b + c + d - e + f - g
	a + b - c + d - e + f - g

	a + b + c + d + e + f + g
	a - b + c + d + e + f + g
	a + b - c + d + e + f + g
	a + b + c - d + e + f + g
	a + b + c + d - e + f + g
	a + b + c + d + e - f + g
	a - b + c - d + e + f + g
	a - b + c + d - e + f + g
	a - b + c + d + e - f + g
	a + b - c + d - e + f + g
	a + b - c + d + e - f + g
	a + b + c - d + e - f + g
	a - b + c - d + e - f + g
 +	34 21  26  24  25  24  26  21
 -	0  13   8  10   6  10   8  13

1
 +	1
 -	0
2
 +	2   1
 -	0   1
3
 +	3   2   2
 -	0   1   1
4
 +	5   3   4   3
 -	0   2   1   2
5
 +	8   5   6   6   5
 -	0   3   2   2   3
6
 +	13  8  10   9  10   8
 -	0   5   3   4   3   5
7
 +	21 13  16  15  15  16  13
 -	0   8   5   6   6   5   8
8
 +	34 21  26  24  25  24  26  21
 -	0  13   8  10   6  10   8  13

	フィボナッチ数列！
	・フィボナッチ数列同士を足した数列もフィボナッチ数列である
	・初項、第2項がa,bのフィボナッチ数列の第n項は基本のフィボナッチ数列を
	  fib[n]としてa*fib[n-1]+b*fib[n-2]とO(1)で求められる
	を使えばOKだった

---------------------------------------------------------------------
ABC204 D
---------------------------------------------------------------------
1 5 3 2
1 3 2 5
	2回

1 2 3 4
3 2 1
	1回

1 2 3
4 5 6
	3回

入れ替え回数は、最大では、相違組の個数

1 2 3
4 5 2
	3回？
	一か所では変わらない？

1 2 3
2 5 2
	3回？
	2が全部で登場しても、変わらない？
力技でOK？

分からんかった、、
解説見た
一致しないといけない数を辺で繋いだ無向グラフとすると、
その連結されている数は全部同じ数値に変換される必要がある。
その変換回数は、その連接成分の要素数-1


---------------------------------------------------------------------
ABC207 B
---------------------------------------------------------------------
A + Bx <= Cx * D
x(CD-B) >= A
CD-B == 0 or < 0 の場合はNG

---------------------------------------------------------------------
ABC207 C
---------------------------------------------------------------------
 2] -> 4]
 2) -> 3]
と変換する
 [2 -> [4
 (2 -> [5

---------------------------------------------------------------------
ABC207 D
---------------------------------------------------------------------
平行移動していいので、対応する最初の点を同じ座標に動かす。
次の対応する点同士の角度と距離を求める
それ以降の各点同士で距離が同じで、角度が最初に求めたのと同じかを確認する
同一円の上にいるってことなので、x^2+y^2が一致するかで判定できるのでは
いや、距離が等しいことは分かるけど、角度が問題

だめ
対応する点が事前にはわからないみたい
集合が一致するかなので、点の順番はどうでもいいみたい

---------------------------------------------------------------------
ABC207 E
---------------------------------------------------------------------
N<=3000 なので O(N^2) まではOK
後ろから累積和しておく
k を決め打ちして順に判定
kを小さい値から順に処理
現在の値を含んで手前で、題意を満たす個数をDP

	1	2	3	4
累積	10	9	7	4
k=1	1	1	1	1
k=2	0	1	0	1
k=3		0	1	0
k=4				1
	答え 3

---------------------------------------------------------------------
ABC208 D
---------------------------------------------------------------------
ワーシャルフロイドか・・・

---------------------------------------------------------------------
ABC211 E
---------------------------------------------------------------------
各マスを起点としてBFSして、distがKなる組み合わせを数える。
右下方向にだけ探索すると、いや、ダメか
	.####.
	......
	######
こういうのがカウントできなくなる
そもそもKマス埋めるっていうのは、どう判定する？
面積を持ってBFSしたらいいのか？
別に最短距離を求めているわけではないので、回り道する場合もある。
	...
	.#.
	.#.
	.#.
	...
マスに連番を振って、塗るマスの中で一番数字の若いマスを起点とすると
決めたらいいのか。
で、起点よりも若いマスには遷移しない


---------------------------------------------------------------------
ABC212 C
---------------------------------------------------------------------
AとBをソートして、A[i]に近い数をBから二分探索で探す
微妙に時間かかったから、想定解ではない？

---------------------------------------------------------------------
ABC212 D
---------------------------------------------------------------------
ボールは優先度キューに入れる
毎回ボールの値を加算すると時間がかかるので、加算値だけで別に累計する

---------------------------------------------------------------------
ABC212 E
---------------------------------------------------------------------
同じ都市を2回通ることはOKなんだろうか？
 OK
DPする
単純に一日ごとに、N個の都市について、前日のH個の都市のの値を合計
とすると、O(N^3)になって多分TLE
今日のN個の都市を計算するときについでにその日の全都市の合計も累積しておくか。
で、橋が壊れている都市については、行先都市毎に値を別途累計しておく

---------------------------------------------------------------------
ABC213 E
---------------------------------------------------------------------
全然わからん
解答見た
壁を壊すのが1x1なら、壁方向に進む時のコストを1にして、ダイクストラでOK
この問題の場合2x2なので、壊した場合にコスト1で飛べる範囲

壊す個所の候補
	 x
	x@x
	 x

2x2範囲で壊すので、例えば以下の様に4マスはコスト1で行けるようになる。
	 xx
	 xx
	 @

	xx
	xx
	 @

	  xx
	 @xx

つまり以下の場所にコスト1で行く枝を張ればOK
	 xxx
	xxxxx
	xx@xx
	xxxxx
	 xxx

---------------------------------------------------------------------
ABC214 C
---------------------------------------------------------------------
久々に挑戦
最初に各位置で渡される時間で初期化して、最初の位置から順に隣に受け渡すのと
自分が受け取ってる時間とを比較して、早い時間で更新していく。
NG

N-1位置から、0位置に渡された奴が一番早い場合が漏れてた。
計算は2周する必要があった
OK

---------------------------------------------------------------------
ABC214 D
---------------------------------------------------------------------
よく見た記憶がある問題
木の2つの頂点間の最短パスに含まれる辺の重みの最大値を、全頂点の組み合わせで総計
含まれる重み、であって、パスの合計の重みではない

愚直に行くなら、
頂点組み合わせ全部(N^2)それぞれで経路をたどって、毎回最大値を記憶して足していく
N <= 10^5 なので、全然間に合わない

逆に求めるなら？
最大値の辺を選んで、それを通るパスを全部列挙する

方針はこれでいいと思うけど、効率のいい実装が思い付かない。。。

行先リストを双方向リストで作成
辺コストの大きい順に選ぶ
その辺を削除して、辺の2つの頂点を起点として、BFSで個数カウント
 → NG

サンプルは通るけど、ほとんどTLEになるし、WAも出る。
通過済みのマークを毎回初期化しているのが N かかるので、これが時間が掛かる原因？
通過済みのマークを毎回ユニークな値で上書きしていく形にして、初期化を無くす。
 → まだ TLE がでる。
    TLEじゃなくなったやつも WA が出ている

解説見る
辺に注目して、両頂点の個数を掛けるのは正しかったけど、
最初に全部グラフを作るのではなく、コストの低い辺から順に構築していく。
で、union findを使って数を数える。

---------------------------------------------------------------------
ABC215 D
---------------------------------------------------------------------
互いに素であることを確認すればいいけど、N^2 かかってTLEする
各Aiごとの 1 ～ M を確認するのがN^2
各Aiから、互いに素じゃない数値をあげていって、1～M から除外したらいいと思う
Ai の倍数を除外後、約数も除外？
けど、それでも N^2 近くかかるような

---------------------------------------------------------------------
ABC217 D
---------------------------------------------------------------------
setで追加し、lower_bound()とupper_bound()で指定位置の左右の切れ目を探す。
-----|------------|-----
     xl    x      xr
指定位置よりも左（小さいほう）を探す場合、
	xl = upper_bound(x)
指定位置よりも右（大きいほう）を探す場合、
	xr = lower_bound(x)






=======================================================================
= ノウハウ
=======================================================================
〇 リストに存在する値の中で、指定した値よりも直近で大きいものと小さいものを求める方法
	lower_bound(x): x >= a   となる a へのイテレータを返す
	upper_bound(x): x >  a   となる a へのイテレータを返す
	どちらも存在しないなら end() を返す
  set<int> S;
  S.insert(1);
  S.insert(3);
  S.insert(6);

  auto a = S.lower_bound(1);
  cout << *a << endl;		// 1 が表示される。以下、この行省略。
  auto a = S.upper_bound(1);	// 3
  auto a = S.lower_bound(2);	// 3
  auto a = S.upper_bound(2);	// 3
  auto a = S.lower_bound(3);	// 3
  auto a = S.upper_bound(3);	// 6

	これを使い指定よりも大きい個所の値を取得し、perv() でその一個前を取得する
  auto a = S.upper_bound(2);	// 3
  auto b = prev(a);		// 1

	欲しい答えが、指定位置を含むか含まないかで、どちらの関数を使うかを決める。






