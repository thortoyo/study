---------------------------------------------------------------------
AGC039 A
---------------------------------------------------------------------
連続文字
2	a a b
	  *		1回
3	a a a b
	  *		1回
4	a a a a b
	  *   *		2回
5	a a a a a b
	  *   * 	2回	n / 2 回
端っこ
	a b c d a	
	        *	1回
	a b c a a	
	        *	1回
	a b a a a	
	    *   *	2回
	a a b a a	
	*     *		2回
最初と最後
	a b a a/a b a a/a b a a
	      *       *       *

---------------------------------------------------------------------
AGC039 B
---------------------------------------------------------------------
頂点は200、辺は40000が最大なので、全部順番に調べれればOK
ある頂点から辺をたどると、必ず隣り合う集合になる。
V1 と Vk は特別で、となりあう集合が1つしかない。
辺がない頂点は、独立の集合にして問題ない。
出自数が1の頂点は、隣り合う集合が2個ある集合にいれても仕方ない？
なので、こいつを探して、V1にしてみる？



---------------------------------------------------------------------
AGC039 C
---------------------------------------------------------------------
011
001
000
100
110
111
011

1011
0101
0010
1001
0100
1010
1101
0110
1011

0000
1000
1100
1110
1111
0111
0011
0001
0000

000
100
110
111
011
001
000

101
010
101


1 0 1
2 3 6

1 1 0
2 4 7

1 1 1
2 4 8

1010
0101

110011
011001
001100
100110
110011


---------------------------------------------------------------------
ABC144 C
---------------------------------------------------------------------
因数分解して、全組み合わせを見て、数字の合計が一番小さいのを選ぶ。

0 1 -> 2
0 1 2 -> 3
1 << 0	1
1 << 1	2
1 << 2	4

16
2 * 2 * 2 * 2
4*4


---------------------------------------------------------------------
ABC145 D
---------------------------------------------------------------------
(6,6) だとすると
(1,2) (2,4) (4,5) (6,6)
(1,2) (3,3) (4,5) (6,6)
(1,2) (3,3) (5,4) (6,6)
(2,1) (3,3) (5,4) (6,6)
どっちの方法を使っても一度に増える座標の合計は 3
なので、XとYを足した合計は3の倍数である必要がある。
で、(X+Y)/3 で必要な手数が出る。
それが 出たら、X と Y から引く。
そこで マイナスになったら NG
あとは単純な格子の場合の数。
X最大は 10^6 だけど、だいたい 1/3 になる
けど、それが X と Y 両方あるとでかいなあ。。。
10^6 = 1,000,000 = 1M
X Y 両方あったら 1T
DPではできない。
 (X+Y)! / (X! * Y!)
で計算できそう。
今回階乗が多いな。

---------------------------------------------------------------------
ABC146 D
---------------------------------------------------------------------
辺を塗り分けるか。
どうやったら辺を塗り分ける判定ができる？
適当に割り当ててみる？
木！
見落としてた！
木やったら簡単。
辺を順番に見ていきながら、同じ頂点からのものならインクリメントしていく。
出し元ノードが変わったら数字を元に戻す。
先ノードにすでにその番号の辺が、、、いや、木だから無い！



-----------------------------------------------------------------------
sumitb2019 D - Lucky PIN
-----------------------------------------------------------------------
順番を守りながら3つ数字を選ぶ。
Nは30000。3*10^4
単純に列挙するのは O(N^3) なので無理。
左から順に処理
最初の三文字の時点では、1個。
最大でも1000個なので、setで管理。
現状でありうる上位2桁を覚えておく。
新たな1桁と、それら上位のセットを全部作って、setに乗せる。
それから新たな1桁を使って、上位のセットを追加する。
 1桁目を2桁目に入れて、新1桁を1桁目に入れる。
 これを上位セットに追加。


-----------------------------------------------------------------------
sumitb2019 E - Colorful Hats 2
-----------------------------------------------------------------------
前から単純に数えていいのか？
i - Ai
0 1 2 0 0 1
1 1 1 2 3 2
          3


-----------------------------------------------------------------------
ABC116 D - Various Sushi
-----------------------------------------------------------------------
種類がなければ普通のDP
種類があるので、どれを取ったかを記憶してないと、カレントのスシを取った時に
種類数を加算するかが判断できない。
事前の準備が多分必要
事前に種類番号でソートしておくと、何とかなりそう
そうしておくと、種類数をインクリメントするときは種類番号の切り替わり時のみ
なので、切り替わり後に、現在の種類をすでに取ったか、だけを把握しておけばいけそう。
	dp[i][j]	i個取っていて、現在の値をすでに
いや、dp[N][K] の時点ですでに 10^10 なので不可！
別の方法を考える必要がある。

種類がなければ、味でソートして大きい順にK個取ればOK。
K個取ってから、残りから種類が異なるものを選んで、その中の味が大きいものと
入れ替えていって、入れ替えても点数が大きくならなくなるまで続ける？
 

-----------------------------------------------------------------------
ABC119 D - Lazy Faith
-----------------------------------------------------------------------

-----------------------------------------------------------------------
ABC115 D
-----------------------------------------------------------------------
BB..B PP..P
  L   
L			total	paty
0	1		1	1
1	3 + 2*L(-1)	5	3	1 + 2*L[-1]
2	3 + 2*L(-1)	13	7	1 + 2*L[-1]
3	3 + 2*L(-1)	29	15	1 + 2*L[-1]


P
	1
B P P P B
	3
B BPPPB P BPPPB B
	3 1 3
B B BPPPB P BPPPB B P B BPPPB P BPPPB B B
	3 1 3 1 3 1 3
B B B BPPPB P BPPPB B P B BPPPB P BPPPB B B P B B BPPPB P BPPPB B P B BPPPB P BPPPB B B B
	3 1 3 1 3 1 3 1 3 1 3 1 3 1 3
	4 3 1 1 1 3 

-----------------------------------------------------------------------
ABC114 C
-----------------------------------------------------------------------
上位の桁から順に累積していくやつ
	2	5	4	9
	0	2*3=6	
	0	1
いや、この問題の場合、各桁は独立して計算可能か

問題間違えた。。。
7 と 5 と 3 がそれぞれ１回以上登場する場合の数
あ、さらに、それ以外の数字が出てこない場合か。
10^9 までの数だけど、実際に探索する必要があるのは 3^8 になるので
全探索が余裕になる

こういうのは、基本は再帰らしい。

-----------------------------------------------------------------------
ABC114 D
-----------------------------------------------------------------------
N! の約数なので、1〜Nまでを素因数分解して、それらから選んだのが約数になる
約数の個数を数える必要がある。
例えば 12 だと、12 = 2*2*3
約数は、1,2,3,4,6,12 の6個
2 が2個、3が1個
2を選ばない場合も含めると、
2を選ぶ個数は 3 パターン、3を選ぶ個数は 2 パターン
	3*2=6
が、約数の個数になる
36 = 2*2*3*3
約数は、1,2,3,4,6,9,12,18,36 の9個
3*3=9 個

約数の合計が75個というのは、
75 = 3*5*5
なので、ありうるパターンとしては
	75
	3, 25
	3, 5, 5
	5, 15
の4パターン

1〜Nの各数を素因数分解して、各素数ごとの合計個数を累積
Nは100未満なので、
innsu[100]
に累積する。
そして、上記4パターンの取りうる数をそれぞれ計算し、合計すればいい。

-----------------------------------------------------------------------
ABC149 D
-----------------------------------------------------------------------

-----------------------------------------------------------------------
ABC149 E
-----------------------------------------------------------------------
Ai 大きい順にソートしておく
一回の握手で点が大きいのは順に
	M/3
A0,A0	0
A0,A1	0
A1,A0	0
A1,A1	1
A1,A2	1
A2,A1	1
A2,A2	2
A2,A3	2
A3,A2	2
A3,A3	3
 :
という順になる
なので、Mを3で割って、そのあまりがいくつかで、場合分けすればいい？
A[M/3-1] までAiを合計。それを6倍。A0*3 を引く。
余り 0	A[M/3]*2を加算
余り 1	A[M/3]*4を加算
余り 2	A[M/3]*5、A[M3+1]を加算

違う！
A0,A0	0
A0,A1	0
A1,A0	0
ここまでは正しいけど、次が A1,A1 か、A0,A2 かは不明

二分探索か。
ある点数が実現可能かを求められればいい。

M回の握手なので、Ai は 2M 個足される。
A1,A0	= A0 + A0 - (A0 - A1)
A1,A1 = A1+A0-(A0-A1) = A0+A0-(A0-A1)-(A0-A1)
A2,A0 = A1+A0-(A1-A2) = A0+A0-(A1-A2)-(A0-A1)

わからん、、、
解説を見る。

N*Nの表ができるので、その表の中から大きい順にM個取った場合が答え。
けど、それでは時間がかかりすぎる。
よって、ある数以上であるマスの個数を数えて、それがMをちょうど超える場合を探す。


-----------------------------------------------------------------------
ABC150 C
-----------------------------------------------------------------------
最大でも8!なので、40320通りしかない。
よって総当たり。
総当たりでPとQとに一致するのを探して、そのときの順番を記憶して答えを出す。

pythonでの順列列挙(辞書順に出力)
import itertools
itertools.pamutations( list )

-----------------------------------------------------------------------
ABC150 D
-----------------------------------------------------------------------
0.5 がなければ、普通に公倍数を求める問題
X = A0 * p0 + A0 * 0.5
X = A1 * p1 + A1 * 0.5
X = A2 * p2 + A2 * 0.5
というX
Xの最小が求まれば、その整数倍も条件を満たすのか？

単純に計算するなら？
 A0に関して、Xの候補を全部挙げる O(M)
 A1に関して、Xの候補を全部挙げて、A0での候補と一致するのを残す O(M)
 で、 O(NM)
なので、間に合わない。

2X = A0 * (p0 * 2 + 1)
2X = A1 * (p1 * 2 + 1)
2X = A2 * (p2 * 2 + 1)
としたら、An の奇数倍の最小公倍数を求めたらいい。
奇数倍の最小公倍数とは？


-----------------------------------------------------------------------
ABC152 E
-----------------------------------------------------------------------
最小公倍数を求めて、各Aをそれで割った値を合計すればいい。
けど、最小公倍数がすごく大きくなる。
python ならいけるかと思って、普通に計算する答えを出したけど、一つだけTLE
どうやって計算量を落とす？
逆元を使って、LCMって計算できるのか？
できない気がする。。
 
-----------------------------------------------------------------------
ABC152 D
-----------------------------------------------------------------------


---------------------------------------------------------------------
ABC153 F
---------------------------------------------------------------------
Xが10^9あるので、各地点で爆弾を置いた場合の影響を求めるのはNG
また、Dも10^9あるので、毎回範囲ないにどのモンスターがいるかを判定するのもNG
候補位置は各Xi＋D と -D の位置のみ、でそれ以外の位置は意味がない。	4*10^5
 いや、1,4,1 と並んでたら、+-D位置のみなら 5 回になるけど、4 の位置に置いたら 4 回
  いや、、1 の +-D 位置で計算したら 4 回が出てくる。
爆弾ダメージはA固定なので、必要な回数はあらかじめ計算可能。
爆弾候補位置のリストに、その爆弾によってHitするモンスターの番号のリスト、までは作ることができる。
問題はどうやって最小を求めるか。


---------------------------------------------------------------------
ABC154 D
---------------------------------------------------------------------
N=5
0  1  2  3  4
2  5  3  4  3
0  2  7 10 14 17
K=3


---------------------------------------------------------------------
ABC104 C
---------------------------------------------------------------------
DP[i][p]: i問題までで、p問解いた時の最大点


---------------------------------------------------------------------
ABC104 D
---------------------------------------------------------------------
Bを固定して考えたらいけそう？
"?" も含んで、先頭から順に B の位置を決めて、その前にある Aの個数、
その後ろにある C の個数を数えて掛け合わせる。
前にあるAの個数は A と ? に合計でOK
個数は、先頭から順にカウントアップしながら AB[i] の配列に入れていけばいい。
i はBの文字位置。
Cの個数も逆に右からもう一回ループ回したらいい

---------------------------------------------------------------------
ABC155 D
---------------------------------------------------------------------
a b c
a

a b c d		6
ab < ac < bc < bd < cd
          ad
a b c d e	10
ab < ac < ad < ae < be < ce < de
          bc < bd < cd

a b c d e f	15
ab < ac < ad < ae < af < bf < cf < df < ef
          bc < bd < be < ce < de
                  cd


bc < bd < be < ce < de


---------------------------------------------------------------------
ABC155 E
---------------------------------------------------------------------
	3	2	4
	3	2	4

		3	0
	7+1	0	6

		0
		7

	0
	6

1
0


	3	0	4

		1	0
		0	6

		0
		9

---------------------------------------------------------------------
pana2020 E
---------------------------------------------------------------------
a-b
b-a
a-c
c-a
b-c
c-b
の最短をそれぞれ求める。
a	len(a)	|---------|
b	len(b)	    |-------------|
		    |-----|
		       ab
		a-ab         b-ab
b	len(b)	|-----------|
c	len(c)	         |--------|
		         |--|
		 b-bc     bc   c-bc
a-ab + b + c -bc
= a+b+c -ab-bc
なので、ab+bc が一番小さいのを選べばOK

bがaに含まれている場合はどうしたらいい？
ba=ab=0 ？
c-a と a-c の比較をすればいけそうだけど、ほんとうにそれが最短か？
一番重なりが小さいほうから探して、後ろが一致したら止まればいい。
前後逆で探索もするので、後ろ一致で途中で止まっても、逆からの探索の時に
残りの位置の比較も行われる。


---------------------------------------------------------------------
ABC160 D
---------------------------------------------------------------------
2*10^3
全頂点からダイクストラすると、
N*NlogN
なので10^7ぐらいなのでぎりぎり？
いや、距離がkなのを探すので
N*N*NlogN
なのでNG

辺が1個追加なのがポイントか。
X - Y が追加
X <= k なら前に1個
N-Y >= k なら後ろに1個

---------------------------------------------------------------------
ABC090 D
---------------------------------------------------------------------
a = bx + K以上
K >= a - bx
b > K

N-K = bx
b = [K+1, N]
k = [K, b)
a-k = bx

	      b
a	+-----+-----+-----+-----+...
	
b  a	1	2	3	4	5
1	0	0	0	0	0
2	1	0	1	0	1
3	1	2	0	1	2
4	1	2	3	0	1
5	1	2	3	4	0

b  a	1	2	3	4	5	6	7	8	9	10
1	0	0	0	0	0	0	0	0	0	0
2	1	0	1	0	1	0	1	0	1	0
3	1	2	0	1	2	0	1	2	0	1
4	1	2	3	0	1	2	3	0	1	2
5	1	2	3	4	0	1	2	3	4	0
6	1	2	3	4	5	0	1	2	3	4
7	1	2	3	4	5	6	0	1	2	3
8	1	2	3	4	5	6	7	0	1	2
9	1	2	3	4	5	6	7	8	0	1
10	1	2	3	4	5	6	7	8	9	0


---------------------------------------------------------------------
ABC162 F
---------------------------------------------------------------------
奇数番目と偶数番目に分けて累積和を取っておく
偶数累積和 AE[i]
奇数累積和 AO[i]

N 偶数の時
 AE と AO の大きい方
N 奇数の時
N = 7 だと 7//2 = 3 で 3個選ぶ。4個外す

N=7
i	0123456
	.  .  .
	. .   .
	 . . . 

N=9
i	012345678
	.  . .  .
	.  .  . .
	.   . . .
	. . .   .
	. .  .  .
	. .   . .
	. .   . .


分かった
端を選択しない場合、それ以外の分の偶数部分和 と 奇数部分和 の大きい方
で、左右の端を選択しない場合は、上記で求まる。
なので、残りは左右の端を選択した場合。
A[0]を選択しているので、A[1]は自動的に外す。
A[N-1]を選択しているので、A[N-2]は自動的に外す。
なので、元の問題からは、数字の数が4減って、選択する数が2減っている。
よって、最初と同じ状況だと考えられるので、
再度、両端を外した場合を考えて、
と進めて真ん中に行くまで進めばいい

N=7
i	0123456
	._   _.
N//2 = 3 → 奇数なので、最後3つになったら、そのうち最大1つを選ぶ

N=9
i	012345689
	._     _.
	._._ _._.
N//2 = 4 → 偶数なので、最後1つになったら、もう選ぶことはない


---------------------------------------------------------------------
ABC164 E
---------------------------------------------------------------------
ワーシャルフロイドで全頂点間の最短時間を求める
時間をキーとするけど、銀貨も同時に累計しておく
で、1 → k の銀貨が S 以下なら、これが答え。
S以上なら、
両替する頂点を経由する。
両替する頂点を全部振って、時間を求めて、最短を求める
2回両替することがベストなケースがあるなら、これではNG
多分あると思う。
2回までなら、もう一回ループを回せばいいだけ？
3回はありうる？

拡張ダイクストラらしい
このネーミングが正解か実ははっきりしないらしいけど。
Aが小さいので、A最大値 * N だけあれば最短距離で目的地まで行ける。
なので、ノードの状態として、ノード番号, 現在持っている銀貨 という2つの状態を持つようにする。
ノード数 50 * A最大値 50 * ノード数 50 あるので、125000 が最大状態数
これに対してダイクストラする。

---------------------------------------------------------------------
ABC088 C
---------------------------------------------------------------------
a1 + b1 = c11
a1 + b2 = c12
a1 + b3 = c13
a2 + b1 = c21
a2 + b2 = c22
a2 + b3 = c23
a3 + b1 = c31
a3 + b2 = c32
a3 + b3 = c33

a1 + b1  a1 + b2  a1 + b3
a2 + b1  a2 + b2  a2 + b3
a2 + b1  a3 + b2  a3 + b3

---------------------------------------------------------------------
ABC165 C
---------------------------------------------------------------------
Aを総当たりする
ではなくて、Aじゃなくて、Aの差分を総当たりしたらいい？
差分の合計が M 以下





